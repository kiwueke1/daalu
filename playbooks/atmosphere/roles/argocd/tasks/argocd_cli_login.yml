---
# Ensure argocd CLI installed
- name: Check if argocd CLI is installed
  delegate_to: localhost
  run_once: true
  ansible.builtin.stat:
    path: "{{ argocd_cli_path }}"
  register: _argocd_cli_stat

- name: Download argocd CLI
  delegate_to: localhost
  run_once: true
  when: not _argocd_cli_stat.stat.exists
  ansible.builtin.get_url:
    url: "{{ argocd_cli_download_url }}"
    dest: "{{ argocd_cli_path }}"
    mode: "0755"

# Read Argo CD admin password using kubectl jsonpath, then decode
- name: Read Argo CD admin password (kubectl jsonpath)
  delegate_to: localhost
  run_once: true
  ansible.builtin.command: >
    kubectl -n {{ argocd_namespace }} get secret argocd-initial-admin-secret
    -o jsonpath="{.data.password}"
  environment:
    KUBECONFIG: "{{ argocd_local_kubeconfig }}"
  register: _argocd_pwd_b64
  changed_when: false

- name: Decode Argo CD admin password
  delegate_to: localhost
  run_once: true
  ansible.builtin.set_fact:
    argocd_admin_password: "{{ _argocd_pwd_b64.stdout | b64decode }}"

# Discover argocd-server Service host + port
- name: Get argocd-server service info
  delegate_to: localhost
  run_once: true
  kubernetes.core.k8s_info:
    kind: Service
    namespace: "{{ argocd_namespace }}"
    name: argocd-server
    kubeconfig: "{{ argocd_local_kubeconfig }}"
  register: _argocd_svc

- name: Assert argocd-server service exists
  delegate_to: localhost
  run_once: true
  ansible.builtin.assert:
    that:
      - _argocd_svc.resources | length > 0
    fail_msg: "argocd-server Service not found in '{{ argocd_namespace }}' namespace."

# Select LoadBalancer host (ip or hostname), fallback to ClusterIP
- name: Select Argo CD API host/port
  delegate_to: localhost
  run_once: true
  ansible.builtin.set_fact:
    argocd_server_host: >-
      {% if _argocd_svc.resources[0].status.loadBalancer is defined
            and _argocd_svc.resources[0].status.loadBalancer.ingress is defined
            and _argocd_svc.resources[0].status.loadBalancer.ingress|length > 0 %}
        {% if _argocd_svc.resources[0].status.loadBalancer.ingress[0].hostname is defined %}
          {{ _argocd_svc.resources[0].status.loadBalancer.ingress[0].hostname }}
        {% elif _argocd_svc.resources[0].status.loadBalancer.ingress[0].ip is defined %}
          {{ _argocd_svc.resources[0].status.loadBalancer.ingress[0].ip }}
        {% else %}
          {{ _argocd_svc.resources[0].spec.clusterIP }}
        {% endif %}
      {% else %}
        {{ _argocd_svc.resources[0].spec.clusterIP }}
      {% endif %}
    argocd_server_port: >-
      {{ (_argocd_svc.resources[0].spec.ports | selectattr("name","equalto","https")
          | map(attribute="port") | list | first) | default(443) }}

# Log into Argo CD CLI
# Build "host:port" safely
- name: Build Argo CD host:port
  delegate_to: localhost
  run_once: true
  vars:
    _port: "{{ argocd_server_port | default(443) }}"
  ansible.builtin.set_fact:
    argocd_hostport: "{{ (argocd_server_host | trim) ~ ':' ~ (_port | string) }}"

# Build the arg list (conditionally adds --insecure)
- name: Build argocd login argv
  delegate_to: localhost
  run_once: true
  ansible.builtin.set_fact:
    argocd_login_argv: >-
      {{
        [ argocd_cli_path, 'login', argocd_hostport, '--username', 'admin', '--password', argocd_admin_password ]
        + (['--insecure'] if (argocd_login_insecure | default(true) | bool) else [])
      }}

# Resolve kubeconfig to an absolute path (avoid 127.0.0.1:8080)
- name: Resolve kubeconfig path
  delegate_to: localhost
  run_once: true
  ansible.builtin.set_fact:
    argocd_kubeconfig_resolved: "{{ argocd_local_kubeconfig | regex_replace('^~', lookup('env','HOME')) }}"

# Log into Argo CD CLI using argv (prevents ':443' splitting)
- name: Log into Argo CD CLI
  delegate_to: localhost
  run_once: true
  ansible.builtin.command:
    argv: "{{ argocd_login_argv }}"
  environment:
    KUBECONFIG: "{{ argocd_kubeconfig_resolved }}"
  register: _argocd_cli_login
  changed_when: "'logged in successfully' in (_argocd_cli_login.stdout | default(''))"
